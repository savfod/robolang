#summary Подсистема "структура кода"

==Изменение==
конкретно сейчас система называется CodeStructure. Мне показалось, что интерпретация это только один процесс - преобразование текста в структуру, действия же типа добавить, удалить - не имеют ничего общего с таким названием. Вследствие чего я переименовал эту часть.
==Общее описание==
Эта часть программы скрывает в себе взаимодействие программы с кодом (кодом пользователя на "роботе"). В такие взаимодействия входят: хранение кода, добавление комманд, удаление комманд, выделение, выполнение...

== Взаимодействие системы с остальными частями == 
1) * с GUI * вся система спрятана в объект CodeStructure, у которого есть функции  
====Отображение кода====
{{{
 special_string GetLine(int LineCount) = 0; // возвращает строчку с номером LineCount
 int            GetLinesCount()=0; // - возвращает количество строк
}}}
====Обработка действий пользователя====
=====мышка=====
{{{ 
 Menu* CreateMenu(int LineCount, int SymbolCount) = 0; //Обработка вызыва меню для символа по номеру строки и номеру символа в строке
}}}
=====стрелки=====
{{{ 
 virtual void Next()=0; 
 virtual void Last()=0;
 virtual void GoInto()=0; 
 virtual void GoOut()=0;
}}}
=====клавиатура=====
{{{
 virtual Menu* CreateMenu()=0; // выдаёт меню для выделенного элемента
}}}





2)  *с полем/роботом* общаются конкретные комманды (которых пока нет) 
 
3) *С меню.* Создаёт меню через специальный объект (менюшную фабрику). Меню же изменяет код напрямую (не трогая объект CodeStructure)

==Конретные решения==
 * хранение команд в виде списка (каждая ссылается на следующую)
====классы====
 # класс комманда - поддерживает выполнение комманды, отображение, знает где следующая. Ниже представлены приблизительные функции  
{{{
 command* do();  // выполняется и даёт указатель на следующую для выполнения комманду
 command* undo();
 command* next();  //  выдаёт следующую по списку комманду (для рисования)
 command* previous();
}}}
 # итераторы - обходить список команд. Для простоты не позволяют обращаться к командам напрямую. Есть два итератора:
  #AccessCommandIterator - используется для действий с командами. Поддерживает операции
{{{
 int               CommandsTotal() // даёт общее число команд.
 special string    GetLine(int LineIndex); // возвращает строку по её номеру
 Menu*             CreateMenu(int LineIndex, int SymbolIndex, MenuMaker* MenuFabric);// создаёт меню
}}}
  #RunCommandIterator - выполняет код. Функции:
{{{ 
 void     First();
 void     DoAndNext();
 bool     bool  IsDone(); 
 bool     int   GetRunningCommandIndex();
}}} 
 # класс специальная строка - в виде экземпляров этого класса и передаётся элементу GUI строка с кодом. Скорее всего состоит из строки в виде html и данных о том, сколько рисовать палочек, что выделенно,...
 # класс условие - занимается вычислением условий и условий от условий (И, ИЛИ, НЕ) древо условий является частью комманды
{{{
 bool     calculate;
}}}
====Отношения классов====
 # У меня было два варианта, как устраивать отношения команды внутри условий, циклов. Мне показалось, что логичнее второй, т.к. что делать с коммандами - это их личная проблема, а то, где они лежат им должно быть безразлично.
   # Сложные комманды (такие у которых внутри есть ещё комманды, например "если") могут хранить список этих комманд. Тогда:
     * комманды внутри должны информировать сложную комманду о своих изменениях (удаление, добавление ещё одной) или же этим должны заниматься сами сложные комманды 
     * более гибкий вариант. Т.к. есть указатель на содержащий элемент, можно реализовать что угодно. Например, можно сообщать составной комманде об изменениях.
   # Сложные комманды хранят лишь указатель на первый элемент, все же комманды хранят указатель на следующий, пока не окажется NULL
     * должна быть специальная команда "начало", которая не удаляется!
     * сложная комманда понятия не имеет, что внутри неё. 
     * Для удаления всей (сложной) комманды, надо попросить всю цепочку удалиться, т.е. поудаляться по-очереди.
     * проще реализовывать ctrl + v для нескольких комманд
     * Да и вообще более простой вариант, сложные комманды не зависят от того, что внутри них происходит