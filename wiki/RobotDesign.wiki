#summary Дизайн программы
#labels Phase-Design

= Что нужно от дизайна =

 # Инкапсуляция. Независимость частей программы друг от друга, для того чтобы можно было менять части по отдельности, в том числе к конкретному сроку, в том числе полностью переделывать, в том числе разным людям. Отсутствие необходимости помнить как устроенно всё, занимаясь той или иной частью.
 # Продвижение. Возможность добавить что-то новое (особенно поля и интерфейс) не переделывая всё написанное.
 
 
= Общее разбиение =
Программу удобно разбить на 5 основных подсистем:
 # GUI - основное окно, включающее менюшки, показывающее код робота
 # Интерпретатор, контейнер кода робота - отвечает за хранение, открытие/сохранение, обход кода робота
 # Поле - хранит поле, то как оно выглядит, плюс умеет себя рисовать.
 # Робот - знает где он на поле хранит внутреннее состояние (в стандартном роботе такого нету, в требованиях - тоже), умеет себя рисовать, скорее всего отвечает за выполнение и знание команд.
 # Графический движок (ГД) - предоставляет свой интерфейс для графической библиотеки. Реализованный на QT позволит разрабатывать поле и робота, через какие-то свои функции, возможно добавляя их по мере необходимости.

== Описания подсистем ==

====GUI====
 # (_Зачем нужен?_)  Выделен в отдельную часть для того, чтобы скрыть от остальных работу с интерфейсом. Следовательно, позволяет изменять реализацию интерфейса и реализацию остальных частей по-отдельности. (GUI и ГД - единственные, кто знают о QT)
 # (_Что делает?_)  Выполняет роль каркаса. Прямо или косвенно запускает все остальные части. Сообщает кому надо о действиях пользователя с интерфейсом (что нажал, что хотел выделить). 
 # (_Как будет развиваться?_)  Будет в программе с самого начала. По мере разработки программы будет усложняться, будут появляться/реализовываться новые функции (например, врядли с самого начала в программе будет возможность отмены (ctrl + Z), скорее всего добавим, когда уже что-то будет работать)

==== Интерпретатор кода ====
 # (_Зачем нужен?_)  Скрывает в себе всю работу с кодом: выполнение, сохранение/открытие, знания, что с кодом можно делать. 
 # (_Что делает?_)  Работает с кодом. Для выполнения должно уметь создавать (прямо или косвенно) поля с роботами.  (!) Создает (скорее всего через ГД) или говорит, как создать меню по работе с кодом (по запросу GUI).
 # (_Как будет развиваться?_)  В любой уже что-нибудь делающей версии должно быть. Будет усложняться по мере разработки. Возможно, будет несколько реализаций интерпретатора (одна для простых пользователей, вторая - для сложных, позволяющий работу с разными полями), но долгое время будет только одна. 

=== Поле ===
 # (_Зачем нужен?_) Скрывает в себе реализацию поля, в т.ч. отрисовку. Выделение в отдельный объект позволит легко добавлять новые поля.
 # (_Что делает?_) Выполняет команды робота. Отвечает на запросы робота. Рисует себя. Просит нарисоваться на себе роботов.
 # (_Как будет развиваться?_) Простое появится более менее сразу. Когда займёмся улучшениями, добавим новые поля (иерархию полей) 

=== Робот ===
 # (_Зачем нужен?_) Для того чтобы у робота было что-то личное. Например, то, как он выглядит. (такой пункт есть в требованиях). Прячет под собой функции поля и выдает свои.
 # (_Что делает?_) Выполняет код по запросу интерпретатора кода. Рисует себя на поле.
 # (_Как будет развиваться?_) Появится когда уже будет работать поле. Хитрые роботы появятся, когда займёмся улучшениями.

=== Графический движок ===
 # (_Зачем нужен?_) Скрывает в себе работу с графикой в операционной системе.
 # (_Что делает?_) Выполняет запросы поля, робота, как кого изобразить (открыть картинку, наложить другую картинку, нарисовать...)
 # (_Как будет развиваться?_) Будет усложняться по мере необходимости. Когда будет оказываться, что полю не хватает каких-то функций для графики, они будут добавляться.


==Разделение обязанностей между основными объектами==
|| || *Данные (код на роботе)* || *GUI* || *Поле* || *Robot* || Графический движок ||
|| Редактирует код || х  || х || || ||  ||
|| Сохраняет/удаляет || х || || || || ||
|| Выделяет несколько команд || || х || || || ||
|| Сtrl + Z (для кода) || х || || || || ||
|| Импортирует в текст || х || || || ||  ||
|| Знает, где роботы || || ||  || х || ||
|| Рисует поле || || || х || || х ||
|| Рисует робота || || ||  || х || х ||
|| Знает о стиле поля || || || х || || х ||
|| Генерирует случайное поле || || || х || || ||
|| Сохраняет/открывает поле  || || || х || || || 
|| Управляет скоростью || || х || || || ||
|| Выполняет до метки || х || || || || ||
|| Работает с тестами || || || х || || ||
|| Ctrl + Z (для выполнения) || х || || х || х ||  ||
|| Выполняет код || х || || х || ? || ||
|| Хранит список доступных команд || || || ? || х || ||
|| -|- условий || || || ? || х || ||
|| -|- направлений || || || х || ? || || 


Поясню некоторые пункты:
 * У поля нет списка роботов на нём. Робот знает, на каком он поле, в какой клетке сейчас.
 * Выполнение кода скорее всего начинается в коде, затем посылается роботу, затем, может быть, посылается полю. (Мало ли какие бывают роботы... Вдруг у него будет плохое настроение и он не захочет идти на север...) Очень сомнительный пункт! Такие плохие роботы и даже просто плохие команды, которые могут выполнять лишь некоторые роботы, не прописаны прямо в требованиях! Хотя вряд ли все роботы могут сносить стенки, даже на специальном поле.
 * Направления скорее всего должны быть в поле, хотя у каких-то роботов могут свои мнения на данный счёт (идти направо, пойти налево, идти куда глаза глядят...)

<wiki:comment>
== Взаимодействие основных объектов ==
 
=== GUI <-> поле, робот, QT, движок ===
не взаимодействуют прямо
=== GUI <-> интерпретатор кода ===
 * взаимодействие обеспечивается тем, что GUI хранит в себе указатель на И.К.  
 * GUI говорит коду, какие в нём произошли изменения
 * код говорит GUI, как выглядит код ( что GUI должен нарисовать )
 * Основной вопрос, кто из них двоих знает, что реально можно делать с кодом. Есть два варианта:
   # Знает интерпретатор кода. В этом случае, достигается логичность (а значит и большая гибкость). Действительно, в этом случае кто знает, как код устроен, тот и знает что с ним делать.
   # Знает GUI. Этот вариант может быть несколько проще. У нас вряд ли будет много вариантов представления кода (кажись у нас конкретные варианты в требованиях). Однако я подозреваю, что мы будем часто менять представления кода во время написания программы (а тем более, варианты, что делать с кодом).   
=== Робот <-> Поле ===
 * Робот знает, где он на поле.
 * Реально роботу посылаются запросы на комманды, условия. Робот посылает запросы полю.
 продолжение списка следует... 
</wiki:comment>
=Дополнительные объекты=
 * Фабричный метод -отдельный объект, который знает, какую именно поля уже реализованы. Позволяет хранить информацию о полях в одном конкретном месте.

=Что нужно сделать=
 # Придумать интерфейсы для основных (и не только) частей.
 # Придумать, как можно реализовать части; продумать, какие классы при этом возникнут.
 # Реализовать.